var documenterSearchIndex = {"docs":
[{"location":"#API-Documentation","page":"API Documentation","title":"API Documentation","text":"","category":"section"},{"location":"","page":"API Documentation","title":"API Documentation","text":"Below is the API documentation for Mixtape.jl","category":"page"},{"location":"","page":"API Documentation","title":"API Documentation","text":"CurrentModule = Mixtape","category":"page"},{"location":"#Interception-interfaces","page":"API Documentation","title":"Interception interfaces","text":"","category":"section"},{"location":"","page":"API Documentation","title":"API Documentation","text":"These interfaces parametrize the Mixtape pipeline and allow you to transform lowered code and insert optimizations. Similar to Cassette.jl – to override these interfaces, users subtype CompilationContext and associated interfaces.","category":"page"},{"location":"","page":"API Documentation","title":"API Documentation","text":"CompilationContext\nallow\ntransform\npreopt!\npostopt!","category":"page"},{"location":"#Mixtape.CompilationContext","page":"API Documentation","title":"Mixtape.CompilationContext","text":"abstract type CompilationContext end\n\nParametrize the Mixtape pipeline by inheriting from CompilationContext. Similar to the context objects in Cassette.jl. By using the interface methods transform, preopt!, and postopt! – the user can control different parts of the compilation pipeline.\n\n\n\n\n\n","category":"type"},{"location":"#Mixtape.allow","page":"API Documentation","title":"Mixtape.allow","text":"allow(f::CompilationContext, args...)::Bool\n\nDetermines whether the user-defined transform, preopt!, and postopt! are allowed to look at a lowered Core.CodeInfo or Core.Compiler.IRCode instance.\n\nThe user is allowed to greenlight modules:\n\nallow(::MyCtx, m::Module) == m == SomeModule\n\nor even specific signatures\n\nallow(::MyCtx, fn::typeof(rand), args...) = true\n\n\n\n\n\n","category":"function"},{"location":"#Mixtape.transform","page":"API Documentation","title":"Mixtape.transform","text":"transform(ctx::CompilationContext, b::Core.CodeInfo)::Core.CodeInfo\ntransform(ctx::CompilationContext, b::Core.CodeInfo, sig::Tuple)::Core.CodeInfo\n\nUser-defined transform which operates on lowered CodeInfo in the form of a CodeInfoTools.Builder object. There's two versions: (1) ignores the signature of the current method body under consideration and (2) provides the signature as sig.\n\nTransforms might typically follow a simple \"swap\" format using CodeInfoTools.Builder:\n\nfunction transform(::MyCtx, src)\n    b = CodeInfoTools.Builder(b)\n    for (k, st) in b\n        b[k] = swap(st))\n    end\n    return CodeInfoTools.finish(b)\nend\n\nbut more advanced formats are possible. For further utilities, please see CodeInfoTools.jl.\n\n\n\n\n\n","category":"function"},{"location":"#Mixtape.preopt!","page":"API Documentation","title":"Mixtape.preopt!","text":"preopt!(ctx::CompilationContext, ir::Core.Compiler.IRCode)::Core.Compiler.IRCode\n\nUser-defined transform which operates on inferred Core.Compiler.IRCode. This transform operates before a set of optimizations which mimic Julia's pipeline.\n\n\n\n\n\n","category":"function"},{"location":"#Mixtape.postopt!","page":"API Documentation","title":"Mixtape.postopt!","text":"postopt!(ctx::CompilationContext, ir::Core.Compiler.IRCode)::Core.Compiler.IRCode\n\nUser-defined transform which operates on inferred Core.Compiler.IRCode. This transform operates after a set of optimizations which mimic Julia's pipeline.\n\n\n\n\n\n","category":"function"},{"location":"#Call-and-codegen-interfaces","page":"API Documentation","title":"Call and codegen interfaces","text":"","category":"section"},{"location":"","page":"API Documentation","title":"API Documentation","text":"These interfaces allow you to apply the Mixtape pipeline with a variety of targets, including:","category":"page"},{"location":"","page":"API Documentation","title":"API Documentation","text":"Emission of inferred and (unoptimized or optimized) Core.CodeInfo for consumption by alternative code generation backends (like Brutus\nExecution of generated code with a linked in OrcJIT instance through GPUCompiler.jl.","category":"page"},{"location":"","page":"API Documentation","title":"API Documentation","text":"The current @load_abi interface creates a special call function in the toplevel module scope which allows the user to access a @generated ABI. call can be used to execute code using the Mixtape pipeline without first creating a callable entry with jit.","category":"page"},{"location":"","page":"API Documentation","title":"API Documentation","text":"warning: Warning\nThe call ABI is currently \"slow\" – it costs an array allocation (for arguments which you will pass over the line in memory). In the future, this will be changed to a fast ABI – but the current slow ABI is mostly stable and useful for prototyping.","category":"page"},{"location":"","page":"API Documentation","title":"API Documentation","text":"jit\nemit\n@load_abi","category":"page"},{"location":"#Mixtape.jit","page":"API Documentation","title":"Mixtape.jit","text":"jit(f::F, tt::Type{T}; ctx = NoContext(),\n    opt = true,\n    optlevel = Base.JLOptions().opt_level) where {F, T <: Type}\n\nCompile and specialize a method instance for signature Tuple{f, tt.parameters...} with pipeline parametrized by ctx::CompilationContext.\n\nReturns a callable instance of Entry{F, RT, TT} where RT is the return type of the instance after inference.\n\nThe user can configure the pipeline with optional arguments:     1. ctx::CompilationContext – configure transform, preopt!, postopt!.     2. opt::Bool – configure whether or not the Julia optimizer is run (including preopt! and postopt!).     3. optlevel::Int > 0 – configure the LLVM optimization level.\n\n\n\n\n\n","category":"function"},{"location":"#Mixtape.emit","page":"API Documentation","title":"Mixtape.emit","text":"emit(@nospecialize(f), tt::Type{T};\n    ctx = NoContext(), opt = false,\n    optlevel = Base.JLOptions().opt_level) where {F <: Function, T <: Tuple}\n\nEmit typed (and optimized if opt = true) CodeInfo using the Mixtape pipeline. The user can configure the pipeline with optional arguments:     1. ctx::CompilationContext – configure transform, preopt!, postopt!.     2. opt::Bool – configure whether or not the Julia optimizer is run (including preopt! and postopt!).     3. optlevel::Int > 0 – configure the LLVM optimization level.\n\n\n\n\n\n","category":"function"},{"location":"#Mixtape.@load_abi","page":"API Documentation","title":"Mixtape.@load_abi","text":"@load_abi()\n...expands...\ncall(f::T, args...; ctx = NoContext(), \n    optlevel = Base.JLOptions().opt_level) where T <: Function\n\nA macro which expands to define an ABI function call into the scope of the calling module. call wraps an @generated function which is called with signature argument types Tuple{f <: Function, args...}. The underlying @generated function creates a new instance of ctx (thus, a nullary constructor is an implicit requirement of your own subtypes of CompilationContext for usage with call) and calls jit – it then caches a ccall which calls a function pointer to the GPUCompiler-compiled LLVM module.\n\nThe call interface currently uses a slow ABI ccall – which costs an array allocation for each toplevel call. This allocation is required to construct a Vector{Any} for the arguments and pass a pointer to it over the line, where the call unboxes each argument.\n\n\n\n\n\n","category":"macro"}]
}
